{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udfaf Mission Statement Application security has become a global risk as organizations are finding it challenging to secure their software infrastructure. The mission of this wiki is to accelerate the transition to secure software development by doing the following: Making secure development practices free and open for everyone to use and conveying them in such a way that is easy to understand and implement Creating awareness among software developers so they take ownership of security Developing a community that supports one another to achieve this mission \ud83d\ude80 Follow us","title":"Welcome"},{"location":"About/","text":"About the Author \ud83d\udd17 \ud83d\udc4b Hello \u0627\u0644\u0633\u0644\u0627\u0645 \u0639\u0644\u06cc\u06a9\u0645, My name is Amir Hamza. I started vulnproof to promote secure coding practices among the software developer community. I have always been passionate about application security, so I started this initiative to make a dent in the application security space. Get in touch with me:","title":"About"},{"location":"About/#about-the-author","text":"\ud83d\udc4b Hello \u0627\u0644\u0633\u0644\u0627\u0645 \u0639\u0644\u06cc\u06a9\u0645, My name is Amir Hamza. I started vulnproof to promote secure coding practices among the software developer community. I have always been passionate about application security, so I started this initiative to make a dent in the application security space. Get in touch with me:","title":"About the Author"},{"location":"Getting-Started/","text":"\ud83d\udce2 Information Credit The information on this site is mostly derived from two reputable sources, Open Web Application Security Project and National Institute of Standards and Technology . Other sources will be included here as the number of topics covered grows. \ud83d\udeb4 How to use Each topic has a checklist that contains security considerations that are recommended but are not required. If you are considering using a checklist for your project, be advised that this should not be a rule to follow. The severity level associated with each item on the checklist represents its importance. It is up to you to decide which one is more appropriate for your project. If you need any clarification, please reach out. \ud83e\udd1d Contribute to vulnproof We would appreciate any contributions that enable us to reach our goal. The option to contribute to this wiki will be made available soon. Stay tuned!","title":"Getting Started"},{"location":"Authentication/UserID-Passwords/","text":"User ID and Password Authentication \ud83d\udd17 \ud83e\udeaa User ID \ud83d\udd17 Following two checklists must be considered for the identifiers that can be used as a User ID. \ud83d\udcdd Username Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : Usernames are case insensitive Reason : Prevent confusion between 'smith' and 'Smith' Low Impersonation xxxxxxxxxx OWASP CS 2 Verify : Usernames are unique Reason : Prevent a username to be used for multiple accounts High Impersonation OWASP CS 3 Verify : Usernames must be at least 6 characters long Reason : Protection against guessing High Bruteforcing OWASP CS 4 Verify : Usernames are not same as some system reserved names such as root, admin, administrator etc. Reason : Prevent user from receiving high privileges High Impersonation OWASP CS \ud83d\udcdd Email Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : Emails are no longer than 254 characters in length Reason : Protection against denial of service Medium DoS xxxxxxxxxxxxxxx OWASP CS 2 Verify : Email receives a PIN for verification. The PIN Security Checklist under Forgot Password must be used for this Reason : Verify user's identity High Impersonation OWASP CS 3 Verify : Emails are unique Reason : Prevent an email to be used for another account High Impersonation OWASP CS \ud83c\udf4e General Password Policies \ud83d\udd17 Following items must be considered during authentication regardless of the type of protocol or authenticator being used. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : All authentication related events must be logged. Such as account lockout, account creation, account login etc. Reason : Trigger alerts when abnormal events occur. Also, helps with investigations High Insufficiant Logging OWASP CS 2 Verify : All user supplied input i.e. passwords, usernames, PINs etc., should never be trusted and must be validated Reason : Protect against injection or Denial of Service (DOS) attacks High SQLi LDAPi XSS DoS OWASP CS 3 Verify : TLS (HTTPS) and Strict-Transport-Security header is enable for every authentication process Reason : Network traffic is encrypted which helps prevention against eavesdropping High Eavesdropping OWASP CS , NIST 4 Verify : Rate limiting mechanisms exist Reason : Prevention against guessing and DoS High Bruteforing DoS NIST \ud83d\udd28 Password Registration \ud83d\udd17 Following items must be considered for the user registration process. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : A password is at least 8 characters in length Reason : Protect against guessing since shorter passwords can be guessed High Bruteforcing xxxxxxxxxxx OWASP CS , NIST 2 Verify : A password's maximum length is at least 64 characters Reason : Protect against password length DoS attacks Low DoS OWASP CS , ASVS , NIST 3 Verify : All ASCCI characters, unicodes and white spaces are considered valid input Reason : Allow user to create a complex password which will make it hard to guess Medium Bruteforcing NIST 4 Verify : Common or previously breached passwords are blocked Reason : Protect against password guessing Medium Bruteforcing OWASP CS , ASVS , NIST 5 Verify : Reuse of old passwords is not allowed Reason : Users are likely to use the same password across many websites which can be a risk if one of those websites is compromised Low Bruteforcing 6 Verify : The user is not asked to set password hints Reason : Reveals information about the password which makes it easier to guess High Bruteforcing ASVS , NIST 7 Verify : The user is notified of an account setup via email Reason : The user is aware of the use of their email on an external website Medium Impersonation ASVS , NIST \ud83d\udea6Password Verification \ud83d\udd17 Following items must be considered for password verification process \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : If account lockout is in place for the provided email, authentication process should not even start Reason : Response time delays during authentication can reveal if an account exist in the database or not Medium Bruteforcing xxxxxxxx 2 Verify : Error responses for failed login attempts are generic such as: username or password is incorrect Reason : Too specific error messages can reveal information about user's account Medium Bruteforcing OWASP CS 3 Verify : Response time for username and password checks during authentication should be the same Reason : Difference in response time can indicate if the one of the provided credentials was found in the database or not Medium Bruteforcing OWASP CS 4 Verify : HTTP status codes during authentication are generic Reason : Too specific error messages can reveal information about user's account Informational Bruteforcing OWASP CS 5 Verify : The secure flag is set for all authentication cookies Reason : Authentication cookie value is encrypted High Eavesdropping XSS OWASP CS , NIST 6 Verify : Sensitive cookie data that is related to authentication is not being cached Reason : Someone else can have access incase a device is left unattended or it gets stolen Low Impersonation Theft OWASP CS , ASVS , NIST 7 Verify : An account is locked after a certain number of failed attempts Reason : Rate limiting mechanism to prevent guessing High Bruteforcing OWASP CS , ASVS 8 Verify : User is notified via email when an account lockout takes place Reason : The user must be aware if someone tried to guess their account so they can change their password High Bruteforcing 9 Verify : Account lockout is not for a fixed time rather it should increase exponentially with each failed login attempt Reason : Rate limiting mechanism that makes it challenging for guessing attacks to occur Medium Bruteforcing OWASP CS , NIST 10 Verify : User is send an email notification if login occurs from a different browser, device, IP or geo location Reason : Incase someone else logged into user's account without their consent Low Impersonation OWASP CS \ud83d\udce6 Password Storage \ud83d\udd17 Following items must be implemented for password storage process \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : Passwords are hashed before storing in the database Reason : Incase of password leak, the hashed passwords won't allow access to an account High SQLi LDAPi Theft Impersonation OWASP CS , ASVS , NIST 2 Verify : Only approved hashing algorithms are used Reason : Unapproved hashing algorithms are insecure since they can be bypassed and clear text values can be extracted High Bruteforcing OWASP CS , ASVS , NIST 3 Verify : A salt is used before hashing passwords Reason : Makes passwords even more complex by adding additional characters to it. Also helps make same passwords used by multiple users different High Bruteforcing OWASP CS , ASVS , NIST 4 Verify : A salt is at least 32 bits in size Reason : Makes it challenging to be guessed High Bruteforcing OWASP CS , ASVS , NIST 5 Verify : Salt is unique for each password Reason : When two users choose the same password, their hash won't be the same as each password is appended to a unique salt High Bruteforcing OWASP CS , ASVS , NIST 6 Verify : Salt is generated by using secure random algorithms Reason : Makes is hard to predict the value of the hash High Bruteforcing OWASP CS , ASVS , NIST 7 Verify : Peppering can be used in addition to salting Reason : Adds additional security to the passwords. Preferred for sensitive accounts Low Bruteforcing OWASP CS 8 Verify : If peppering is used, it is stored in a password vault Reason : Incase of a database or codebase compromise the safe storage of peppering will help prevent password cracking High Bruteforcing OWASP CS 9 Verify : Pepper rotation policy is in place Reason : Incase of a leak, rotation policy will force a new pepper to be used High Bruteforcing Theft OWASP CS 10 Verify : Pepper is produced by using secure random algorithms Reason : Makes is challenging to predict the value High Bruteforcing OWASP CS \ud83d\udd03 Password Reset \ud83d\udd17 Following items must be implemented for password reset process. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : User is required to reauthenticate before a password reset Reason : Ensure that the actual user is making a change not someone else High Impersonation xxxxxxxx OWASP CS , NIST 2 Verify : User is required to type the new password twice Reason : Helps prevent typing mistakes mistakes Medium \u26d4 NIST 3 Verify : Email notification is sent to this user when password change is successful Reason : Incase user did not authorized a password change they should know someone else did Medium Impersonation OWASP CS , NIST Continue ... Verify that the new password must follows the Password Registration checklist \ud83d\ude15 Forgot Password \ud83d\udd17 When a user chooses forgot password, this can be done through multiple ways: Generate a PIN which can be sent to the user with the provided email or phone number. This PIN needs to be confirmed before password reset is allowed Create a token and pass it into the query string, create a limited session around that unique URL and send it to the user's email Recovery/Backup codes can also be used to give access when the user can't remember their password. Some application might rely on security questions for password reset Danger Security questions should NOT be used. If your application uses security questions, you can find a checklist to secure them here Following items must be considered for using PINS, URL tokens or Backup Codes. \ud83d\udcdd PIN Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : PIN must be 6 to 12 digits long Reason : Protection against guessing High Bruteforcing xxxxxxxx OWASP CS 2 Verify : PIN is unique and is generated using secure random algorithms Reason : Protection against guessing since a random value is hard to predict High Bruteforcing OWASP CS 3 Verify : PIN must be sent to either email or phone number that the user provided Reason : The possession of the PIN verifies their identity High Impersonation OWASP CS 4 Verify : A limited time session is permitted for the PIN until it expires Reason : Incase the PIN leaks through an email/phone compromise, it no longer active after a few minutes High Impersonation Theft OWASP CS 5 Verify : Use Password Storage policies for hashing the PIN when its being stored Reason : Helps against database compromise or PIN leakage High Theft OWASP CS 6 Verify : A generic message is shown if the email provided exists or not such as: \"A PIN is sent to the provided email if it exists in the database\" Reason : Too specific error messages can reveal information about user's account Medium Bruteforcing OWASP CS 7 Verify : PIN is checked for validity before the user is able to set the set a new password Reason : Likelihood of a logic error is high when PIN validity check and password reset happens together Low Logic Error Impersonation OWASP CS 8 Verify : PIN in invalidated once it has been used Reason : Prevent the reuse of the PIN High Impersonation Theft OWASP CS \ud83d\udcdd URL Token Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : Token is generated using secure random algorithms Reason : Protection against guessing since a random value is hard to predict High Bruteforcing xxxxxxxxxxx OWASP CS 2 Verify : Use Password Storage policies for hashing the token when its being stored Reason : Helps against database compromise or token leakage High Theft OWASP CS 3 Verify : URL is hard-coded rather that relying on host header Reason : Protection against host header injection Medium HHi OWASP CS 4 Verify : The reset password page uses Referrer Policy tag with the noreferrer value Reason : Prevention against referrer leakage Medium Referrer Leakage OWASP CS 5 Verify : A limited session is allowed for the URL token before it expires Reason : Incase the token leaks through an email/phone compromise, it no longer active after a few minutes High Impersonation Theft OWASP CS 6 Verify : Token is checked for validity before the user is able to set the set a new password Reason : Ensure that request is coming from the intended user High Impersonation OWASP CS 7 Verify : Token in invalidated once it has been used Reason : Prevent the reuse of the token High Impersonation Theft OWASP CS \ud83d\udcdd Recovery/Backup Code Security Checklist: Recovery/Backup code security checklist can be viewed here Continue ... Once the user has been confirmed, then Password Reset checklist must be used to check functionality for the reset process \ud83d\udcdc Additional Password Policies \ud83d\udd17 Following items must also be considered. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : Password expiration is in place Reason : Incase password leaks it is no longer active forever Medium Impersonation Theft OWASP CS , NIST 2 Verify : Application requires the user to reauthenticate for sensitive features such as payment, updating password or email etc. Reason : Ensure that request is coming from the intended user High Impersonation OWASP CS , NIST 3 Verify : User has the option to set a second or multi factor authentication Reason : Password leak won't impact because the second factor is still not compromised High Impersonation Theft OWASP CS , ASVS , NIST 4 Verify : Reauthentication takes places after a period of inactivity Reason : Someone else cant use a user's device if it is left unattended or forgot to logout High Impersonation OWASP CS , NIST \ud83d\udd17 References: Open Web Application Security Project (OWASP): Application Security Verification Checklist - Authentication Authentication Cheat Sheet Password Storage Cheat Sheet Forgot Password Cheat Sheet Input Validation Cheat Sheet National Institute of Standards and Technology (NIST) SP 800-63B: 5.1.1.2 Memorized Secret Verifiers","title":"User ID & Password"},{"location":"Authentication/UserID-Passwords/#user-id-and-password-authentication","text":"","title":"User ID and Password Authentication"},{"location":"Authentication/UserID-Passwords/#user-id","text":"Following two checklists must be considered for the identifiers that can be used as a User ID. \ud83d\udcdd Username Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : Usernames are case insensitive Reason : Prevent confusion between 'smith' and 'Smith' Low Impersonation xxxxxxxxxx OWASP CS 2 Verify : Usernames are unique Reason : Prevent a username to be used for multiple accounts High Impersonation OWASP CS 3 Verify : Usernames must be at least 6 characters long Reason : Protection against guessing High Bruteforcing OWASP CS 4 Verify : Usernames are not same as some system reserved names such as root, admin, administrator etc. Reason : Prevent user from receiving high privileges High Impersonation OWASP CS \ud83d\udcdd Email Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : Emails are no longer than 254 characters in length Reason : Protection against denial of service Medium DoS xxxxxxxxxxxxxxx OWASP CS 2 Verify : Email receives a PIN for verification. The PIN Security Checklist under Forgot Password must be used for this Reason : Verify user's identity High Impersonation OWASP CS 3 Verify : Emails are unique Reason : Prevent an email to be used for another account High Impersonation OWASP CS","title":"\ud83e\udeaa User ID"},{"location":"Authentication/UserID-Passwords/#general-password-policies","text":"Following items must be considered during authentication regardless of the type of protocol or authenticator being used. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : All authentication related events must be logged. Such as account lockout, account creation, account login etc. Reason : Trigger alerts when abnormal events occur. Also, helps with investigations High Insufficiant Logging OWASP CS 2 Verify : All user supplied input i.e. passwords, usernames, PINs etc., should never be trusted and must be validated Reason : Protect against injection or Denial of Service (DOS) attacks High SQLi LDAPi XSS DoS OWASP CS 3 Verify : TLS (HTTPS) and Strict-Transport-Security header is enable for every authentication process Reason : Network traffic is encrypted which helps prevention against eavesdropping High Eavesdropping OWASP CS , NIST 4 Verify : Rate limiting mechanisms exist Reason : Prevention against guessing and DoS High Bruteforing DoS NIST","title":"\ud83c\udf4e General Password Policies"},{"location":"Authentication/UserID-Passwords/#password-registration","text":"Following items must be considered for the user registration process. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : A password is at least 8 characters in length Reason : Protect against guessing since shorter passwords can be guessed High Bruteforcing xxxxxxxxxxx OWASP CS , NIST 2 Verify : A password's maximum length is at least 64 characters Reason : Protect against password length DoS attacks Low DoS OWASP CS , ASVS , NIST 3 Verify : All ASCCI characters, unicodes and white spaces are considered valid input Reason : Allow user to create a complex password which will make it hard to guess Medium Bruteforcing NIST 4 Verify : Common or previously breached passwords are blocked Reason : Protect against password guessing Medium Bruteforcing OWASP CS , ASVS , NIST 5 Verify : Reuse of old passwords is not allowed Reason : Users are likely to use the same password across many websites which can be a risk if one of those websites is compromised Low Bruteforcing 6 Verify : The user is not asked to set password hints Reason : Reveals information about the password which makes it easier to guess High Bruteforcing ASVS , NIST 7 Verify : The user is notified of an account setup via email Reason : The user is aware of the use of their email on an external website Medium Impersonation ASVS , NIST","title":"\ud83d\udd28 Password Registration"},{"location":"Authentication/UserID-Passwords/#password-verification","text":"Following items must be considered for password verification process \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : If account lockout is in place for the provided email, authentication process should not even start Reason : Response time delays during authentication can reveal if an account exist in the database or not Medium Bruteforcing xxxxxxxx 2 Verify : Error responses for failed login attempts are generic such as: username or password is incorrect Reason : Too specific error messages can reveal information about user's account Medium Bruteforcing OWASP CS 3 Verify : Response time for username and password checks during authentication should be the same Reason : Difference in response time can indicate if the one of the provided credentials was found in the database or not Medium Bruteforcing OWASP CS 4 Verify : HTTP status codes during authentication are generic Reason : Too specific error messages can reveal information about user's account Informational Bruteforcing OWASP CS 5 Verify : The secure flag is set for all authentication cookies Reason : Authentication cookie value is encrypted High Eavesdropping XSS OWASP CS , NIST 6 Verify : Sensitive cookie data that is related to authentication is not being cached Reason : Someone else can have access incase a device is left unattended or it gets stolen Low Impersonation Theft OWASP CS , ASVS , NIST 7 Verify : An account is locked after a certain number of failed attempts Reason : Rate limiting mechanism to prevent guessing High Bruteforcing OWASP CS , ASVS 8 Verify : User is notified via email when an account lockout takes place Reason : The user must be aware if someone tried to guess their account so they can change their password High Bruteforcing 9 Verify : Account lockout is not for a fixed time rather it should increase exponentially with each failed login attempt Reason : Rate limiting mechanism that makes it challenging for guessing attacks to occur Medium Bruteforcing OWASP CS , NIST 10 Verify : User is send an email notification if login occurs from a different browser, device, IP or geo location Reason : Incase someone else logged into user's account without their consent Low Impersonation OWASP CS","title":"\ud83d\udea6Password Verification"},{"location":"Authentication/UserID-Passwords/#password-storage","text":"Following items must be implemented for password storage process \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : Passwords are hashed before storing in the database Reason : Incase of password leak, the hashed passwords won't allow access to an account High SQLi LDAPi Theft Impersonation OWASP CS , ASVS , NIST 2 Verify : Only approved hashing algorithms are used Reason : Unapproved hashing algorithms are insecure since they can be bypassed and clear text values can be extracted High Bruteforcing OWASP CS , ASVS , NIST 3 Verify : A salt is used before hashing passwords Reason : Makes passwords even more complex by adding additional characters to it. Also helps make same passwords used by multiple users different High Bruteforcing OWASP CS , ASVS , NIST 4 Verify : A salt is at least 32 bits in size Reason : Makes it challenging to be guessed High Bruteforcing OWASP CS , ASVS , NIST 5 Verify : Salt is unique for each password Reason : When two users choose the same password, their hash won't be the same as each password is appended to a unique salt High Bruteforcing OWASP CS , ASVS , NIST 6 Verify : Salt is generated by using secure random algorithms Reason : Makes is hard to predict the value of the hash High Bruteforcing OWASP CS , ASVS , NIST 7 Verify : Peppering can be used in addition to salting Reason : Adds additional security to the passwords. Preferred for sensitive accounts Low Bruteforcing OWASP CS 8 Verify : If peppering is used, it is stored in a password vault Reason : Incase of a database or codebase compromise the safe storage of peppering will help prevent password cracking High Bruteforcing OWASP CS 9 Verify : Pepper rotation policy is in place Reason : Incase of a leak, rotation policy will force a new pepper to be used High Bruteforcing Theft OWASP CS 10 Verify : Pepper is produced by using secure random algorithms Reason : Makes is challenging to predict the value High Bruteforcing OWASP CS","title":"\ud83d\udce6 Password Storage"},{"location":"Authentication/UserID-Passwords/#password-reset","text":"Following items must be implemented for password reset process. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : User is required to reauthenticate before a password reset Reason : Ensure that the actual user is making a change not someone else High Impersonation xxxxxxxx OWASP CS , NIST 2 Verify : User is required to type the new password twice Reason : Helps prevent typing mistakes mistakes Medium \u26d4 NIST 3 Verify : Email notification is sent to this user when password change is successful Reason : Incase user did not authorized a password change they should know someone else did Medium Impersonation OWASP CS , NIST Continue ... Verify that the new password must follows the Password Registration checklist","title":"\ud83d\udd03 Password Reset"},{"location":"Authentication/UserID-Passwords/#forgot-password","text":"When a user chooses forgot password, this can be done through multiple ways: Generate a PIN which can be sent to the user with the provided email or phone number. This PIN needs to be confirmed before password reset is allowed Create a token and pass it into the query string, create a limited session around that unique URL and send it to the user's email Recovery/Backup codes can also be used to give access when the user can't remember their password. Some application might rely on security questions for password reset Danger Security questions should NOT be used. If your application uses security questions, you can find a checklist to secure them here Following items must be considered for using PINS, URL tokens or Backup Codes. \ud83d\udcdd PIN Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : PIN must be 6 to 12 digits long Reason : Protection against guessing High Bruteforcing xxxxxxxx OWASP CS 2 Verify : PIN is unique and is generated using secure random algorithms Reason : Protection against guessing since a random value is hard to predict High Bruteforcing OWASP CS 3 Verify : PIN must be sent to either email or phone number that the user provided Reason : The possession of the PIN verifies their identity High Impersonation OWASP CS 4 Verify : A limited time session is permitted for the PIN until it expires Reason : Incase the PIN leaks through an email/phone compromise, it no longer active after a few minutes High Impersonation Theft OWASP CS 5 Verify : Use Password Storage policies for hashing the PIN when its being stored Reason : Helps against database compromise or PIN leakage High Theft OWASP CS 6 Verify : A generic message is shown if the email provided exists or not such as: \"A PIN is sent to the provided email if it exists in the database\" Reason : Too specific error messages can reveal information about user's account Medium Bruteforcing OWASP CS 7 Verify : PIN is checked for validity before the user is able to set the set a new password Reason : Likelihood of a logic error is high when PIN validity check and password reset happens together Low Logic Error Impersonation OWASP CS 8 Verify : PIN in invalidated once it has been used Reason : Prevent the reuse of the PIN High Impersonation Theft OWASP CS \ud83d\udcdd URL Token Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : Token is generated using secure random algorithms Reason : Protection against guessing since a random value is hard to predict High Bruteforcing xxxxxxxxxxx OWASP CS 2 Verify : Use Password Storage policies for hashing the token when its being stored Reason : Helps against database compromise or token leakage High Theft OWASP CS 3 Verify : URL is hard-coded rather that relying on host header Reason : Protection against host header injection Medium HHi OWASP CS 4 Verify : The reset password page uses Referrer Policy tag with the noreferrer value Reason : Prevention against referrer leakage Medium Referrer Leakage OWASP CS 5 Verify : A limited session is allowed for the URL token before it expires Reason : Incase the token leaks through an email/phone compromise, it no longer active after a few minutes High Impersonation Theft OWASP CS 6 Verify : Token is checked for validity before the user is able to set the set a new password Reason : Ensure that request is coming from the intended user High Impersonation OWASP CS 7 Verify : Token in invalidated once it has been used Reason : Prevent the reuse of the token High Impersonation Theft OWASP CS \ud83d\udcdd Recovery/Backup Code Security Checklist: Recovery/Backup code security checklist can be viewed here Continue ... Once the user has been confirmed, then Password Reset checklist must be used to check functionality for the reset process","title":"\ud83d\ude15 Forgot Password"},{"location":"Authentication/UserID-Passwords/#additional-password-policies","text":"Following items must also be considered. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : Password expiration is in place Reason : Incase password leaks it is no longer active forever Medium Impersonation Theft OWASP CS , NIST 2 Verify : Application requires the user to reauthenticate for sensitive features such as payment, updating password or email etc. Reason : Ensure that request is coming from the intended user High Impersonation OWASP CS , NIST 3 Verify : User has the option to set a second or multi factor authentication Reason : Password leak won't impact because the second factor is still not compromised High Impersonation Theft OWASP CS , ASVS , NIST 4 Verify : Reauthentication takes places after a period of inactivity Reason : Someone else cant use a user's device if it is left unattended or forgot to logout High Impersonation OWASP CS , NIST \ud83d\udd17 References: Open Web Application Security Project (OWASP): Application Security Verification Checklist - Authentication Authentication Cheat Sheet Password Storage Cheat Sheet Forgot Password Cheat Sheet Input Validation Cheat Sheet National Institute of Standards and Technology (NIST) SP 800-63B: 5.1.1.2 Memorized Secret Verifiers","title":"\ud83d\udcdc Additional Password Policies"},{"location":"Authentication/MFA/Authenticator%20Security/","text":"Physical Authenticators: Incase of theft the physical authenticator the CSP shall provide a mechanism to revoke or suspend the authenticator immediately when the user notifies the CSP about it Rate Limiting \ud83d\udd17 Rate limiting is to prevent an attacker from guessing the secret. Following measures must be taken to prevent that from happening: The maximum number of failed attempts should be no more than 100 User is required to complete a CAPTCHA before attempting to authenticate Increase wait time after a few failed attempts as the account approaches the max invalid attempts. The wait time should go up exponentially. Starting from 30 seconds up to an hour. Accepting requests only from white listed IP addresses where the user has authenticated before Use other factors to determine user behavior such as IP addresses, geo location, browser metadata/ID or time of the day when the request is being made When the subscriber successfully authenticates, the verifier SHOULD disregard any previous failed attempts for that user from the same IP address. Attestation \ud83d\udd17 An attestation is information conveyed to the verifier regarding a directly-connected authenticator or the endpoint involved in an authentication operation. Information conveyed by attestation MAY include, but is not limited to: The provenance (e.g., manufacturer or supplier certification), health, and integrity of the authenticator and endpoint. Security features of the authenticator Security and performance characteristics of biometric sensors Sensor functionality Sensor false positive rate or error rate If this attestation is signed, it SHALL be signed using a digital signature that provides at least the minimum security strength of 112 bits Verifier Impersonation Resistance \ud83d\udd17 Phishing sites that attempts to fool the user to authenticate. To prevent this following measures must be undertaken: Establish a authenticated protected channel with the verifier It should then attach a value to the authenticator output which is used to prove the authenticators identity to the verifier and hence results in establishing a secure channel. This can be done by signing the value with the authenticator output using a private key that the user controls for which the public key is known to the verifier This is then verified before any authenticator output is accepted Approved cryptographic algorithms must be used to establish verifier impersonation resistance. Cryptographic keys for this signing shall be at least 112 bits in length Authenticators that involve manually entry of the authenticator output such as out of band or OTP authenticators must not considered verifier impersonation resistant because the manual entry does not bind the authenticator output to the specific session being authentication. Verifier and Credential Service Provider Communications: \ud83d\udd17 In a situation where the verifier and credential service provider are different, such as using a third party MFA solution such as OKTA or Ping, the following should be considered: Ensure communication between both occurs through manually authenticated secure channel such as a client-authenticated TLS connection Ensure approved cryptography is used for authentication Verifier-Compromise Resistance \ud83d\udd17 Authentication protocols that do not require the verifier to persistently store secrets that could be used for authentication are considered strong and are described as verifier compromise resistance. An example of this are the OTP verifiers who independently generate the same output as the authenticator and just compare the value input by the user. Note that these verifiers are not resistant to all attacks. Verifier compromise resistance can be achieved in different ways: Use a cryptographic authenticator that requires the verifier store a public key corresponding to a private key held by the authenticator. Store the expected authenticator output in hashed form. This method can be used with some look-up secret authenticators Ensure that approved cryptographic algorithms are used Ensure that cryptographic keys are of 112 bits of length minimum Replay Resistance \ud83d\udd17 An authentication process resists replay attacks if it is impractical to achieve a successful authentication by recording and replaying a previous authentication message. Protocols that use nonces or challenges to prove the \u201cfreshness\u201d of the transaction are resistant to replay attacks since the verifier will easily detect when old protocol messages are replayed since they will not contain the appropriate nonces or timeliness data In contrast, memorized secrets are not considered replay resistant because the authenticator output \u2014 the secret itself \u2014 is provided for each authentication. Meaning that the value remains the same. Authentication Intent \ud83d\udd17 An authentication process demonstrates intent if it requires the subject to explicitly respond to each authentication or reauthentication request. The goal of authentication intent is to make it more difficult for directly-connected physical authenticators (e.g., multi-factor cryptographic devices) to be used without the subject\u2019s knowledge, such as by malware on the endpoint. Authentication intent SHALL be established by the authenticator itself, although multi-factor cryptographic devices MAY establish intent by reentry of the other authentication factor on the endpoint with which the authenticator is used Authentication processes that require the subject\u2019s intervention (e.g., a claimant entering an authenticator output from an OTP device) establish intent. Cryptographic devices that require user action (e.g., pushing a button or reinsertion) for each authentication or reauthentication operation are also establish intent. Depending on the modality, presentation of a biometric may or may not establish authentication intent. Presentation of a fingerprint would normally establish intent, while observation of the claimant\u2019s face using a camera normally would not by itself. Behavioral biometrics similarly are less likely to establish authentication intent because they do not always require a specific action on the claimant\u2019s part. Restricted Authenticators \ud83d\udd17 If an organization continues to use a restricted authenticator, the following aspect must be considered: What is the level of risk associated with the use of a restricted authenticator Analyze the level of impact incase the authenticator is bypassed If the risk is unacceptable, then the restricted authenticator should not be used What can be done to mitigate the excessive risk Develop a migration plan for the future so that eventually the restricted authenticator is no longer used If a restricted authenticator factor is being used by customers, following must be notified to them: Risk associated with use of the restricted authenticator factor Provide additional unrestricted authenticators for them to switch to Develop a migration plan for the future so that eventually the restricted authenticator is no longer used","title":"Authenticator Security"},{"location":"Authentication/MFA/Authenticator%20Security/#rate-limiting","text":"Rate limiting is to prevent an attacker from guessing the secret. Following measures must be taken to prevent that from happening: The maximum number of failed attempts should be no more than 100 User is required to complete a CAPTCHA before attempting to authenticate Increase wait time after a few failed attempts as the account approaches the max invalid attempts. The wait time should go up exponentially. Starting from 30 seconds up to an hour. Accepting requests only from white listed IP addresses where the user has authenticated before Use other factors to determine user behavior such as IP addresses, geo location, browser metadata/ID or time of the day when the request is being made When the subscriber successfully authenticates, the verifier SHOULD disregard any previous failed attempts for that user from the same IP address.","title":"Rate Limiting"},{"location":"Authentication/MFA/Authenticator%20Security/#attestation","text":"An attestation is information conveyed to the verifier regarding a directly-connected authenticator or the endpoint involved in an authentication operation. Information conveyed by attestation MAY include, but is not limited to: The provenance (e.g., manufacturer or supplier certification), health, and integrity of the authenticator and endpoint. Security features of the authenticator Security and performance characteristics of biometric sensors Sensor functionality Sensor false positive rate or error rate If this attestation is signed, it SHALL be signed using a digital signature that provides at least the minimum security strength of 112 bits","title":"Attestation"},{"location":"Authentication/MFA/Authenticator%20Security/#verifier-impersonation-resistance","text":"Phishing sites that attempts to fool the user to authenticate. To prevent this following measures must be undertaken: Establish a authenticated protected channel with the verifier It should then attach a value to the authenticator output which is used to prove the authenticators identity to the verifier and hence results in establishing a secure channel. This can be done by signing the value with the authenticator output using a private key that the user controls for which the public key is known to the verifier This is then verified before any authenticator output is accepted Approved cryptographic algorithms must be used to establish verifier impersonation resistance. Cryptographic keys for this signing shall be at least 112 bits in length Authenticators that involve manually entry of the authenticator output such as out of band or OTP authenticators must not considered verifier impersonation resistant because the manual entry does not bind the authenticator output to the specific session being authentication.","title":"Verifier Impersonation Resistance"},{"location":"Authentication/MFA/Authenticator%20Security/#verifier-and-credential-service-provider-communications","text":"In a situation where the verifier and credential service provider are different, such as using a third party MFA solution such as OKTA or Ping, the following should be considered: Ensure communication between both occurs through manually authenticated secure channel such as a client-authenticated TLS connection Ensure approved cryptography is used for authentication","title":"Verifier and Credential Service Provider Communications:"},{"location":"Authentication/MFA/Authenticator%20Security/#verifier-compromise-resistance","text":"Authentication protocols that do not require the verifier to persistently store secrets that could be used for authentication are considered strong and are described as verifier compromise resistance. An example of this are the OTP verifiers who independently generate the same output as the authenticator and just compare the value input by the user. Note that these verifiers are not resistant to all attacks. Verifier compromise resistance can be achieved in different ways: Use a cryptographic authenticator that requires the verifier store a public key corresponding to a private key held by the authenticator. Store the expected authenticator output in hashed form. This method can be used with some look-up secret authenticators Ensure that approved cryptographic algorithms are used Ensure that cryptographic keys are of 112 bits of length minimum","title":"Verifier-Compromise Resistance"},{"location":"Authentication/MFA/Authenticator%20Security/#replay-resistance","text":"An authentication process resists replay attacks if it is impractical to achieve a successful authentication by recording and replaying a previous authentication message. Protocols that use nonces or challenges to prove the \u201cfreshness\u201d of the transaction are resistant to replay attacks since the verifier will easily detect when old protocol messages are replayed since they will not contain the appropriate nonces or timeliness data In contrast, memorized secrets are not considered replay resistant because the authenticator output \u2014 the secret itself \u2014 is provided for each authentication. Meaning that the value remains the same.","title":"Replay Resistance"},{"location":"Authentication/MFA/Authenticator%20Security/#authentication-intent","text":"An authentication process demonstrates intent if it requires the subject to explicitly respond to each authentication or reauthentication request. The goal of authentication intent is to make it more difficult for directly-connected physical authenticators (e.g., multi-factor cryptographic devices) to be used without the subject\u2019s knowledge, such as by malware on the endpoint. Authentication intent SHALL be established by the authenticator itself, although multi-factor cryptographic devices MAY establish intent by reentry of the other authentication factor on the endpoint with which the authenticator is used Authentication processes that require the subject\u2019s intervention (e.g., a claimant entering an authenticator output from an OTP device) establish intent. Cryptographic devices that require user action (e.g., pushing a button or reinsertion) for each authentication or reauthentication operation are also establish intent. Depending on the modality, presentation of a biometric may or may not establish authentication intent. Presentation of a fingerprint would normally establish intent, while observation of the claimant\u2019s face using a camera normally would not by itself. Behavioral biometrics similarly are less likely to establish authentication intent because they do not always require a specific action on the claimant\u2019s part.","title":"Authentication Intent"},{"location":"Authentication/MFA/Authenticator%20Security/#restricted-authenticators","text":"If an organization continues to use a restricted authenticator, the following aspect must be considered: What is the level of risk associated with the use of a restricted authenticator Analyze the level of impact incase the authenticator is bypassed If the risk is unacceptable, then the restricted authenticator should not be used What can be done to mitigate the excessive risk Develop a migration plan for the future so that eventually the restricted authenticator is no longer used If a restricted authenticator factor is being used by customers, following must be notified to them: Risk associated with use of the restricted authenticator factor Provide additional unrestricted authenticators for them to switch to Develop a migration plan for the future so that eventually the restricted authenticator is no longer used","title":"Restricted Authenticators"},{"location":"Authentication/MFA/Authenticator-Management/","text":"A number of events can occur over the lifecycle of a subscriber\u2019s authenticator that affect that authenticator\u2019s use. These events include authenticator registration, verification, reset, and loss. This section describes the actions to be taken in response to those events. \ud83c\udf4e General Policies \ud83d\udd17 \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : All authenticator related events are logged. Such as registering new authenticator, authenticator lost, incorrect authenticator value etc. Reason : Trigger alerts when abnormal events occur. Also, helauth with investigations High Insufficient Logging xxxxxxxxxxxxxxxxxxxxxxx OWASP CS , ASVS , NIST 2 Verify : All user supplied input i.e. PINs, secrets, code etc., should never be trusted and must be validated Reason : Prevention against injection or Denial of Service (DOS) attacks High SQLi LDAPi XSS DoS OWASP CS 3 Verify : TLS (HTTauth) and Strict-Transport-Security header are enable for every authentication process Reason : Network traffic is encrypted which helauth prevents eavesdropping High Eavesdropping OWASP CS , ASVS 4 Verify : Rate limiting mechanisms exist Reason : Prevention against guessing and DoS High Bruteforing DoS OWASP CS , ASVS , NIST 5 Verify : At least two factors can be used. \"something you know\" must be following by either a \"something you have\" or \"something you are\" Reason : Decreases the likelihood of account compromise since possession of two factor is needed High Theft OWASP CS , ASVS , NIST 6 Verify : The website should maintain a record of all authenticators that are associated with an account Reason : Helauth with revocation and deletion of authenticators High Theft NIST 7 Verify : Email notifications must be sent for sensitive operations such as authenticator registration, reset, lost and account lockout Reason : Incase the user didn't authorize these operations, the notification will alert them about it High Impersonation OWASP CS , ASVS , NIST \ud83d\udd28 Authenticator Registration \ud83d\udd17 Following items must be considered for authenticator registration process. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : Website supports at least two factors Reason : Two or more factors are more secure than only one factor High Bruteforcing Theft NIST 2 Verify : Authenticator registration should take place either during user registration or when the user chooses Reason : Decision up to the website owner to make Informational \u26d4 NIST 3 Verify : If a user tries to register an authenticator, they should be reauthenticated by using the existing factor Reason : Confirm that the actual user is registering an authenticator not someone else High Impersonation NIST 4 Verify : Guidelines for the Type of authenticator being registered are considered Reason : Ensure that unique security policies for each authenticator are considered High \u26d4 NIST 5 Verify : Authenticator expiration should be set Reason : Prevent an attacker to have access forever Low Impersonation Theft NIST \ud83d\udea6 Authenticator Verification \ud83d\udd17 Following items that be considered for authenticator verification process. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : If authenticator expiration policy exists, stop the execution and return an expired message if the authenticator is expired Reason : Limit the use of resources Medium Theft xxxxxxxxxxxxxxxxxx NIST 2 Verify : Authenticator verification should happens after Memorized Secret Reason : Revealing information to an attacker about which second factor is being used Low Information Leakage NIST 3 Verify : Authenticator verification should take place in a limited time Reason : Less time an attacker has to respond High Impersonation Theft NIST 4 Verify : An account is locked after a certain number of failed attempts Reason : Limit the use of guessing High Bruteforing NIST \ud83d\udd03 Authenticator Reset \ud83d\udd17 Following items must be considered for authenticator reset process. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : User should be reauthenticated before an authenticator reset takes place Reason : Ensure that the actual user is making a change not someone else High Impersonation xxxxxxxxxxxx NIST 2 Verify : User is required to verify the authenticator's output before it is accepted Reason : Ensure the possession of the authenticator High Impersonation Theft NIST 3 Verify : Guidelines for the Type of authenticator being registered must be considered Reason : Ensure that unique security policies for each authenticator are considered High \u26d4 NIST 4 Verify : Once a new authenticator is established, the website should revoke the previous authenticator Reason : Incase an attacker gets a hold of the old authenticator, it shouldn't work High Impersonation Theft NIST \ud83d\ude15 Authenticator Lost \ud83d\udd17 Following items must be considered for authenticator lost process. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : When a user reports an authenticator lost, they should be reauthenticated Reason : Confirm that the actual user is making the lost claim not someone else High Impersonation xxxxxxxxxxxxxxxxxxxxxxx NIST 2 Verify : If a user reports a lost authenticator during the verification stage at login, a PIN or token URL strategy from Reset Password must be followed Reason : Establish a secure way for a user to change their authenticator High Impersonation Theft NIST 3 Verify : After a successful identity check, the website must ask the user to register a new authenticator Reason : Replace the lost authenticator High Impersonation Theft NIST 4 Verify : The lost authenticator no longer works with the user's account Reason : Incase an attacker gets a hold of the authenticator, it shouldn't work High Impersonation Theft NIST \ud83d\udd17 References: Open Web Application Security Project (OWASP): Application Security Verification Checklist - Authentication Authentication Cheat Sheet National Institute of Standards and Technology (NIST) SP 800-63B: 5 Authenticator and Verifier Requirements","title":"Authenticator Management"},{"location":"Authentication/MFA/Authenticator-Management/#general-policies","text":"\ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : All authenticator related events are logged. Such as registering new authenticator, authenticator lost, incorrect authenticator value etc. Reason : Trigger alerts when abnormal events occur. Also, helauth with investigations High Insufficient Logging xxxxxxxxxxxxxxxxxxxxxxx OWASP CS , ASVS , NIST 2 Verify : All user supplied input i.e. PINs, secrets, code etc., should never be trusted and must be validated Reason : Prevention against injection or Denial of Service (DOS) attacks High SQLi LDAPi XSS DoS OWASP CS 3 Verify : TLS (HTTauth) and Strict-Transport-Security header are enable for every authentication process Reason : Network traffic is encrypted which helauth prevents eavesdropping High Eavesdropping OWASP CS , ASVS 4 Verify : Rate limiting mechanisms exist Reason : Prevention against guessing and DoS High Bruteforing DoS OWASP CS , ASVS , NIST 5 Verify : At least two factors can be used. \"something you know\" must be following by either a \"something you have\" or \"something you are\" Reason : Decreases the likelihood of account compromise since possession of two factor is needed High Theft OWASP CS , ASVS , NIST 6 Verify : The website should maintain a record of all authenticators that are associated with an account Reason : Helauth with revocation and deletion of authenticators High Theft NIST 7 Verify : Email notifications must be sent for sensitive operations such as authenticator registration, reset, lost and account lockout Reason : Incase the user didn't authorize these operations, the notification will alert them about it High Impersonation OWASP CS , ASVS , NIST","title":"\ud83c\udf4e General Policies"},{"location":"Authentication/MFA/Authenticator-Management/#authenticator-registration","text":"Following items must be considered for authenticator registration process. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : Website supports at least two factors Reason : Two or more factors are more secure than only one factor High Bruteforcing Theft NIST 2 Verify : Authenticator registration should take place either during user registration or when the user chooses Reason : Decision up to the website owner to make Informational \u26d4 NIST 3 Verify : If a user tries to register an authenticator, they should be reauthenticated by using the existing factor Reason : Confirm that the actual user is registering an authenticator not someone else High Impersonation NIST 4 Verify : Guidelines for the Type of authenticator being registered are considered Reason : Ensure that unique security policies for each authenticator are considered High \u26d4 NIST 5 Verify : Authenticator expiration should be set Reason : Prevent an attacker to have access forever Low Impersonation Theft NIST","title":"\ud83d\udd28 Authenticator Registration"},{"location":"Authentication/MFA/Authenticator-Management/#authenticator-verification","text":"Following items that be considered for authenticator verification process. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : If authenticator expiration policy exists, stop the execution and return an expired message if the authenticator is expired Reason : Limit the use of resources Medium Theft xxxxxxxxxxxxxxxxxx NIST 2 Verify : Authenticator verification should happens after Memorized Secret Reason : Revealing information to an attacker about which second factor is being used Low Information Leakage NIST 3 Verify : Authenticator verification should take place in a limited time Reason : Less time an attacker has to respond High Impersonation Theft NIST 4 Verify : An account is locked after a certain number of failed attempts Reason : Limit the use of guessing High Bruteforing NIST","title":"\ud83d\udea6 Authenticator Verification"},{"location":"Authentication/MFA/Authenticator-Management/#authenticator-reset","text":"Following items must be considered for authenticator reset process. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : User should be reauthenticated before an authenticator reset takes place Reason : Ensure that the actual user is making a change not someone else High Impersonation xxxxxxxxxxxx NIST 2 Verify : User is required to verify the authenticator's output before it is accepted Reason : Ensure the possession of the authenticator High Impersonation Theft NIST 3 Verify : Guidelines for the Type of authenticator being registered must be considered Reason : Ensure that unique security policies for each authenticator are considered High \u26d4 NIST 4 Verify : Once a new authenticator is established, the website should revoke the previous authenticator Reason : Incase an attacker gets a hold of the old authenticator, it shouldn't work High Impersonation Theft NIST","title":"\ud83d\udd03 Authenticator Reset"},{"location":"Authentication/MFA/Authenticator-Management/#authenticator-lost","text":"Following items must be considered for authenticator lost process. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify : When a user reports an authenticator lost, they should be reauthenticated Reason : Confirm that the actual user is making the lost claim not someone else High Impersonation xxxxxxxxxxxxxxxxxxxxxxx NIST 2 Verify : If a user reports a lost authenticator during the verification stage at login, a PIN or token URL strategy from Reset Password must be followed Reason : Establish a secure way for a user to change their authenticator High Impersonation Theft NIST 3 Verify : After a successful identity check, the website must ask the user to register a new authenticator Reason : Replace the lost authenticator High Impersonation Theft NIST 4 Verify : The lost authenticator no longer works with the user's account Reason : Incase an attacker gets a hold of the authenticator, it shouldn't work High Impersonation Theft NIST \ud83d\udd17 References: Open Web Application Security Project (OWASP): Application Security Verification Checklist - Authentication Authentication Cheat Sheet National Institute of Standards and Technology (NIST) SP 800-63B: 5 Authenticator and Verifier Requirements","title":"\ud83d\ude15 Authenticator Lost"},{"location":"Authentication/MFA/Overview/","text":"Multi Factor Authentication (MFA) Overview \ud83d\udd17","title":"Overview"},{"location":"Authentication/MFA/Overview/#multi-factor-authentication-mfa-overview","text":"","title":"Multi Factor Authentication (MFA) Overview"},{"location":"Authentication/MFA/Session%20Management/","text":"An authenticated session must be started as soon as the user authenticates with all the factors. The session should in place until it is terminated Session can be terminated due to a number of reasons: inactivity, logout event. The session can continue through a reauthentication event Session Binding \ud83d\udd17 Session secret must be shared between the user's software (web browser or application) and the website the user is trying to access The session value from the user's software must be validated against a cryptographic mechanism The session secret must be generated by the website that the user is trying to access, after a successful authentication event The session secret must be generated by using approved random functions The secret must have at least 64 bit entropy The session should be removed/erased when the user logs out The session secret should not be placed in insecure browser storage such as local storage since local storage is prone to cross site scripting attacks The session secret must be shared with the user's software through an authenticated protected channel The session shall time out after a limited time from 15 to 30 mins The session should not be available in http after authentication Proper input validation must take place to ensure that no injection attacks occur Browser cookies \ud83d\udd17 Session cookies should have a secure flag on (HTTPS) Session should be accessible to minimum hostnames and paths Session cookies should be httponly Access Tokens \ud83d\udd17 Access token, similar to OAuth, is used to allow an application to access a set of services on a subscriber's account's behalf following an authentication event. An active OAuth token should not be used as a active session because OAuth tokens can be active even after the user has logged out Reauthentication \ud83d\udd17 A authentication session must be continued as long as the user has a session secret that is Still valid and was issues after the authentication process Session secret should be non-persistent meaning that they should not be valid once the application is restarted (browser/app closed and reopen) or reboot of the host device Period reauthentication of the session should be performed to confirm the continued presence of the user The session should not exceed the time limits for inactivity Right before expiring, the time limit must be extended by prompting the user for reauthentication","title":"Session Management"},{"location":"Authentication/MFA/Session%20Management/#session-binding","text":"Session secret must be shared between the user's software (web browser or application) and the website the user is trying to access The session value from the user's software must be validated against a cryptographic mechanism The session secret must be generated by the website that the user is trying to access, after a successful authentication event The session secret must be generated by using approved random functions The secret must have at least 64 bit entropy The session should be removed/erased when the user logs out The session secret should not be placed in insecure browser storage such as local storage since local storage is prone to cross site scripting attacks The session secret must be shared with the user's software through an authenticated protected channel The session shall time out after a limited time from 15 to 30 mins The session should not be available in http after authentication Proper input validation must take place to ensure that no injection attacks occur","title":"Session Binding"},{"location":"Authentication/MFA/Session%20Management/#browser-cookies","text":"Session cookies should have a secure flag on (HTTPS) Session should be accessible to minimum hostnames and paths Session cookies should be httponly","title":"Browser cookies"},{"location":"Authentication/MFA/Session%20Management/#access-tokens","text":"Access token, similar to OAuth, is used to allow an application to access a set of services on a subscriber's account's behalf following an authentication event. An active OAuth token should not be used as a active session because OAuth tokens can be active even after the user has logged out","title":"Access Tokens"},{"location":"Authentication/MFA/Session%20Management/#reauthentication","text":"A authentication session must be continued as long as the user has a session secret that is Still valid and was issues after the authentication process Session secret should be non-persistent meaning that they should not be valid once the application is restarted (browser/app closed and reopen) or reboot of the host device Period reauthentication of the session should be performed to confirm the continued presence of the user The session should not exceed the time limits for inactivity Right before expiring, the time limit must be extended by prompting the user for reauthentication","title":"Reauthentication"},{"location":"Authentication/MFA/Types/","text":"Types of Authentication Factors \ud83d\udd17 This section covers the different types of authentication factors that are available and their security considerations. Each type is divided into the following categories: Factor Definition Types Example Something you know A value that a user remembers Memorized Secret Something you have The possession of a unique value Look-up Secrets , Out-of-Band Devices , Single and Multi Factor OTP Devices and Single and Multi-factor Cryptographic Software or Device Something you are A physical attribute of a user that is unique to them Biometric Something you know \ud83d\udd17 \ud83e\udde0 Memorized Secrets \ud83d\udd17 \ud83d\udd36 Definition: A secret value intended to be chosen and memorized by the user \ud83d\udd36 Example: Passwords Security Questions \ud83d\udcdd Password Security Checklist: Note Password security checklist can be found here \ud83d\udcdd Security Questions Security Checklist: Danger Security questions should NOT be used as it is considered RESTRICTED in NIST SP 800-63B 5.1.1.2 #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify: Security questions are not used as an authentication factor Reason: Weak form of authentication as value can be easily guessed High Bruteforcing xxxxxxx OWASP CS 2 Verify: Simple answers such as '123' are restricted Reason: Easily guessable value High Bruteforcing OWASP CS 3 Verify: User is required to reauthenticate when updating security questions Reason: Ensure that request is coming from the intended user High Impersonation OWASP CS 4 Verify: More than one question is asked to increase complexity Reason: Makes guessing harder High Bruteforcing OWASP CS 5 Verify: Questions that are being asked are specific to each user instead of generic questions Reason: Generic questions have generic answers and are easily guessable High Bruteforcing OWASP CS 6 Verify: Security questions are presented after when the username and password are accepted Reason: Security questions should only be used as a sector factor because its not as strong as passwords High Bruteforcing OWASP CS 7 Verify: Security questions are hashed when stored in the database and must follow the Password Storage guidelines Reason: Incase answers leak, the hash value won't allow access to an account High Impersonation Theft OWASP CS Something you have \ud83d\udd17 \ud83d\udcd6 Look-up Secrets \ud83d\udd17 \ud83d\udd36 Definition: Look-up secrets are a set of secrets shared between the user and a website. \ud83d\udd36 Example: Acts as a recovery/backup codes when the user forgets their password or locks their account. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify: Look-up secret has at least 112 bit of entropy Reason: Minimum randomness that makes guessing challenging High Bruteforcing xxxxxxx NIST 2 Verify: Verifier retains only a hashed version of the look-up secrets which follow the Password Storage guidelines Reason: Incase lookup secret leaks, the hash value won't allow access to an account High Bruteforcing Impersonation Theft NIST 3 Verify: If entropy is less than 112 bit, the lookup secret is hashed with a salt that's of a 32 bit length Reason: Compensate lower entropy with a salt which will increase entropy High Bruteforcing NIST 4 Verify: If the the look-up secret's entropy is less than 64 bits, rate limiting mechanisms shall be put in place Reason: Additional prevention against guessing to compensate for lower entropy High Bruteforcing NIST 5 Verify: Look-up secret is accepted only once Reason: Prevent a value to be used more than once incase it leaks High Replay Attack NIST 6 Verify: User is required to reauthenticate with two factors when requesting new look-up secrets Reason: Ensure that the actual user is making a change not someone else High Impersonation Theft NIST 7 Verify: Once new look-up secrets are generated, older once are no longer relevant Reason: Prevent reuse incase of theft High Theft NIST \ud83d\udcf1 Out-of-Band Devices \ud83d\udd17 \ud83d\udd36 Definition: Secure out of band authenticators are physical devices that can communicate with the verifier over a secure secondary channel. \ud83d\udd36 Example: Push notifications to mobile devices for authentication SMS or phone call to deliver an authentication code Danger OTP delivered through SMS or phone is not secure and is considered RESTRICTED in NIST 5.1.3.3 \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify: Phone and SMS should are not being used as a out of band verifier Reason: Considered as a restricted category by NIST High Theft Impersonation xxxxxxx NIST 2 Verify: Out of band verifier expires requests, codes, or tokens after 10 minutes Reason: If the verifier doesn't receive the code in under 10 minutes it indicates something is wrong. Maybe the user did not receive the code or it was sent to someone else High Theft NIST 3 Verify: Authentication secrets, codes, or tokens are only usable once, and only for the original authentication request Reason: Prevent reuse incase of theft High Theft Impersonation NIST 4 Verify: Verifier retains only a hashed version of the authentication code which follow the Password Storage guidelines Reason: Incase code leaks, the hash value won't allow access to an account High Theft Impersonation NIST 5 Verify: Authentication code is generated by a secure random number generator, containing at least 20 bits of entropy (typically a six digital random number is sufficient) Reason: Make is challenging to predict the value High Bruteforcing NIST | \ud83d\udd22 Single and Multi Factor OTP Devices \ud83d\udd17 \ud83d\udd36 Definition: Single factor One time Password (OTP) devices are physical devices that generate OTPs Multi factor OTP devices are similar to single factor OTP device but they must be activated by either something you know or something you are or both \ud83d\udd36 Example: The OTP is displayed on the device and manually input for transmission to the verifier, thereby proving possession and control of the device. An OTP device may, for example, display 6 characters at a time. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify: Approved cryptography is used to generate the secret that will be shared with the authenticator Reason: Weak cryptography can be bypassed High Bruteforcing NIST 2 Verify: Approved authenticated protected channel are used when collecting the OTP Reason: Ensures that the OTP is being generated from the right device High Eavesdropping NIST 3 Verify: Time-based OTPs expiration is in place Reason: Prevents the OTP from being reuse incase its stolen High Theft Impersonation Replay Attack NIST 4 Verify: Time-based OTP can be used only once within the validity period Reason: Prevents the OTP from being reuse incase its stolen High Theft Impersonation Replay Attack NIST 5 Verify: Symmetric keys used to verify submitted OTPs are highly protected, such as by using a hardware security module or secure operating system based key storage Reason: Key theft can allow an attacker to generate their own secrets High Theft Impersonation NIST 6 Verify: Physical single factor OTP generator can be revoked in case of theft or other loss. Ensure that revocation is immediately effective across logged in sessions, regardless of location Reason: Prevent a malicious actor to gain access to the user's account High Theft Impersonation Replay Attack NIST 7 Verify: There's a way for the verifier to establish the authenticator as a multi factor device. In the absence of this, the verifier should treat it as a single factor Reason: Ensures that a user is choosing the right authentication factor High Theft Bruteforcing NIST \ud83d\udd11 Single and Multi Factor Cryptographic Device and Software \ud83d\udd17 \ud83d\udd36 Definitions: A single-factor cryptographic device is a hardware device that performs cryptographic operations using protected cryptographic key(s) and provides the authenticator output via direct connection to the user endpoint A Multi-factor cryptographic device is similar to single-factor cryptographic device but it must be activated by either something you know or something you are or both. A single-factor cryptographic software is a cryptographic key stored on disk or some other \"soft\" media. Authentication is accomplished by proving possession and control of the key A Multi-factor cryptographic software is similar to single-factor cryptographic software but it must be activated by either something you know or something you are or both. \ud83d\udd36 Examples: Single/Multi-factor cryptographic device: USB authenticator such as a YubiKey or Google Titan Smart cards with an embedded processor Single/Multi-factor cryptographic software: Use of a client X.509 certificate \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify: Cryptographic keys are highly protected Reason: Key theft can allow an attacker to generate their own secrets High Theft Impersonation NIST 2 Verify: Challenge nonce is at least 64 bits in length Reason: Minimum length that makes prediction of the value challenging High Bruteforcing NIST 3 Verify: Challenge nonce is unique for each authenticator Reason: Ensures that more than one authenticators are not used for a single user account High Impersonation NIST 4 Verify: Approved cryptographic algorithms are used in the generation, seeding, and verification Reason: Unapproved algorithms can be bypassed High Bruteforcing NIST Something you are \ud83d\udd17 \ud83e\uddec Biometric \ud83d\udd17 \ud83d\udd36 Definition: The use of biometrics in authentication includes both measurement of physical characteristics and behavioral characteristics of a user \ud83d\udd36 Example: Facial recognition Finger print scan Iris scan Typing cadence \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify: Biometric authenticators are limited to use only as secondary factors in conjunction with either something you have and something you know Reason: False match rate in Biometric isn't strong enough to be used as a single factor High Impersonation xxxxxxxxxxxxxxxx NIST 2 Verify: Sensor or endpoint is authenticated prior to capturing the biometric sample from the user Reason: Prevent the user of fraudulent devices High Impersonation NIST 3 Verify: Biometric system allows no more than 5 consecutive failed authentication attempts Reason: Limit the occurrence of impersonation attacks High Impersonation NIST 4 Verify: After 5 consecutive failed attempts disable authentication for 30 seconds before next attempt and increase exponentially with each successive failed attempt or disable the biometric user authentication and offer another factor Reason: Limit guessing High Bruteforcing NIST 5 Verify: Integrity of the endpoint or sensor can be determined so any sensor or endpoint change can be detected Reason: Prevent an attacker from installing a fraudulent device to bypass biometric check High Impersonation NIST \ud83d\udd17 References: Open Web Application Security Project (OWASP): Application Security Verification Checklist - Authentication Authentication Cheat Sheet Security Question Cheat Sheet National Institute of Standards and Technology (NIST) SP 800-63B: 5 Authenticator and Verifier Requirements","title":"Types"},{"location":"Authentication/MFA/Types/#types-of-authentication-factors","text":"This section covers the different types of authentication factors that are available and their security considerations. Each type is divided into the following categories: Factor Definition Types Example Something you know A value that a user remembers Memorized Secret Something you have The possession of a unique value Look-up Secrets , Out-of-Band Devices , Single and Multi Factor OTP Devices and Single and Multi-factor Cryptographic Software or Device Something you are A physical attribute of a user that is unique to them Biometric","title":"Types of Authentication Factors"},{"location":"Authentication/MFA/Types/#something-you-know","text":"","title":"Something you know"},{"location":"Authentication/MFA/Types/#memorized-secrets","text":"\ud83d\udd36 Definition: A secret value intended to be chosen and memorized by the user \ud83d\udd36 Example: Passwords Security Questions \ud83d\udcdd Password Security Checklist: Note Password security checklist can be found here \ud83d\udcdd Security Questions Security Checklist: Danger Security questions should NOT be used as it is considered RESTRICTED in NIST SP 800-63B 5.1.1.2 #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify: Security questions are not used as an authentication factor Reason: Weak form of authentication as value can be easily guessed High Bruteforcing xxxxxxx OWASP CS 2 Verify: Simple answers such as '123' are restricted Reason: Easily guessable value High Bruteforcing OWASP CS 3 Verify: User is required to reauthenticate when updating security questions Reason: Ensure that request is coming from the intended user High Impersonation OWASP CS 4 Verify: More than one question is asked to increase complexity Reason: Makes guessing harder High Bruteforcing OWASP CS 5 Verify: Questions that are being asked are specific to each user instead of generic questions Reason: Generic questions have generic answers and are easily guessable High Bruteforcing OWASP CS 6 Verify: Security questions are presented after when the username and password are accepted Reason: Security questions should only be used as a sector factor because its not as strong as passwords High Bruteforcing OWASP CS 7 Verify: Security questions are hashed when stored in the database and must follow the Password Storage guidelines Reason: Incase answers leak, the hash value won't allow access to an account High Impersonation Theft OWASP CS","title":"\ud83e\udde0 Memorized Secrets"},{"location":"Authentication/MFA/Types/#something-you-have","text":"","title":"Something you have"},{"location":"Authentication/MFA/Types/#look-up-secrets","text":"\ud83d\udd36 Definition: Look-up secrets are a set of secrets shared between the user and a website. \ud83d\udd36 Example: Acts as a recovery/backup codes when the user forgets their password or locks their account. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify: Look-up secret has at least 112 bit of entropy Reason: Minimum randomness that makes guessing challenging High Bruteforcing xxxxxxx NIST 2 Verify: Verifier retains only a hashed version of the look-up secrets which follow the Password Storage guidelines Reason: Incase lookup secret leaks, the hash value won't allow access to an account High Bruteforcing Impersonation Theft NIST 3 Verify: If entropy is less than 112 bit, the lookup secret is hashed with a salt that's of a 32 bit length Reason: Compensate lower entropy with a salt which will increase entropy High Bruteforcing NIST 4 Verify: If the the look-up secret's entropy is less than 64 bits, rate limiting mechanisms shall be put in place Reason: Additional prevention against guessing to compensate for lower entropy High Bruteforcing NIST 5 Verify: Look-up secret is accepted only once Reason: Prevent a value to be used more than once incase it leaks High Replay Attack NIST 6 Verify: User is required to reauthenticate with two factors when requesting new look-up secrets Reason: Ensure that the actual user is making a change not someone else High Impersonation Theft NIST 7 Verify: Once new look-up secrets are generated, older once are no longer relevant Reason: Prevent reuse incase of theft High Theft NIST","title":"\ud83d\udcd6 Look-up Secrets"},{"location":"Authentication/MFA/Types/#out-of-band-devices","text":"\ud83d\udd36 Definition: Secure out of band authenticators are physical devices that can communicate with the verifier over a secure secondary channel. \ud83d\udd36 Example: Push notifications to mobile devices for authentication SMS or phone call to deliver an authentication code Danger OTP delivered through SMS or phone is not secure and is considered RESTRICTED in NIST 5.1.3.3 \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify: Phone and SMS should are not being used as a out of band verifier Reason: Considered as a restricted category by NIST High Theft Impersonation xxxxxxx NIST 2 Verify: Out of band verifier expires requests, codes, or tokens after 10 minutes Reason: If the verifier doesn't receive the code in under 10 minutes it indicates something is wrong. Maybe the user did not receive the code or it was sent to someone else High Theft NIST 3 Verify: Authentication secrets, codes, or tokens are only usable once, and only for the original authentication request Reason: Prevent reuse incase of theft High Theft Impersonation NIST 4 Verify: Verifier retains only a hashed version of the authentication code which follow the Password Storage guidelines Reason: Incase code leaks, the hash value won't allow access to an account High Theft Impersonation NIST 5 Verify: Authentication code is generated by a secure random number generator, containing at least 20 bits of entropy (typically a six digital random number is sufficient) Reason: Make is challenging to predict the value High Bruteforcing NIST |","title":"\ud83d\udcf1 Out-of-Band Devices"},{"location":"Authentication/MFA/Types/#single-and-multi-factor-otp-devices","text":"\ud83d\udd36 Definition: Single factor One time Password (OTP) devices are physical devices that generate OTPs Multi factor OTP devices are similar to single factor OTP device but they must be activated by either something you know or something you are or both \ud83d\udd36 Example: The OTP is displayed on the device and manually input for transmission to the verifier, thereby proving possession and control of the device. An OTP device may, for example, display 6 characters at a time. \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify: Approved cryptography is used to generate the secret that will be shared with the authenticator Reason: Weak cryptography can be bypassed High Bruteforcing NIST 2 Verify: Approved authenticated protected channel are used when collecting the OTP Reason: Ensures that the OTP is being generated from the right device High Eavesdropping NIST 3 Verify: Time-based OTPs expiration is in place Reason: Prevents the OTP from being reuse incase its stolen High Theft Impersonation Replay Attack NIST 4 Verify: Time-based OTP can be used only once within the validity period Reason: Prevents the OTP from being reuse incase its stolen High Theft Impersonation Replay Attack NIST 5 Verify: Symmetric keys used to verify submitted OTPs are highly protected, such as by using a hardware security module or secure operating system based key storage Reason: Key theft can allow an attacker to generate their own secrets High Theft Impersonation NIST 6 Verify: Physical single factor OTP generator can be revoked in case of theft or other loss. Ensure that revocation is immediately effective across logged in sessions, regardless of location Reason: Prevent a malicious actor to gain access to the user's account High Theft Impersonation Replay Attack NIST 7 Verify: There's a way for the verifier to establish the authenticator as a multi factor device. In the absence of this, the verifier should treat it as a single factor Reason: Ensures that a user is choosing the right authentication factor High Theft Bruteforcing NIST","title":"\ud83d\udd22 Single and Multi Factor OTP Devices"},{"location":"Authentication/MFA/Types/#single-and-multi-factor-cryptographic-device-and-software","text":"\ud83d\udd36 Definitions: A single-factor cryptographic device is a hardware device that performs cryptographic operations using protected cryptographic key(s) and provides the authenticator output via direct connection to the user endpoint A Multi-factor cryptographic device is similar to single-factor cryptographic device but it must be activated by either something you know or something you are or both. A single-factor cryptographic software is a cryptographic key stored on disk or some other \"soft\" media. Authentication is accomplished by proving possession and control of the key A Multi-factor cryptographic software is similar to single-factor cryptographic software but it must be activated by either something you know or something you are or both. \ud83d\udd36 Examples: Single/Multi-factor cryptographic device: USB authenticator such as a YubiKey or Google Titan Smart cards with an embedded processor Single/Multi-factor cryptographic software: Use of a client X.509 certificate \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify: Cryptographic keys are highly protected Reason: Key theft can allow an attacker to generate their own secrets High Theft Impersonation NIST 2 Verify: Challenge nonce is at least 64 bits in length Reason: Minimum length that makes prediction of the value challenging High Bruteforcing NIST 3 Verify: Challenge nonce is unique for each authenticator Reason: Ensures that more than one authenticators are not used for a single user account High Impersonation NIST 4 Verify: Approved cryptographic algorithms are used in the generation, seeding, and verification Reason: Unapproved algorithms can be bypassed High Bruteforcing NIST","title":"\ud83d\udd11 Single and Multi Factor Cryptographic Device and Software"},{"location":"Authentication/MFA/Types/#something-you-are","text":"","title":"Something you are"},{"location":"Authentication/MFA/Types/#biometric","text":"\ud83d\udd36 Definition: The use of biometrics in authentication includes both measurement of physical characteristics and behavioral characteristics of a user \ud83d\udd36 Example: Facial recognition Finger print scan Iris scan Typing cadence \ud83d\udcdd Security Checklist: #\ufe0f\u20e3 \u2705Items \u26a0\ufe0fSeverity \ud83d\udde1\ufe0fAttacks \ud83d\udd17Sources 1 Verify: Biometric authenticators are limited to use only as secondary factors in conjunction with either something you have and something you know Reason: False match rate in Biometric isn't strong enough to be used as a single factor High Impersonation xxxxxxxxxxxxxxxx NIST 2 Verify: Sensor or endpoint is authenticated prior to capturing the biometric sample from the user Reason: Prevent the user of fraudulent devices High Impersonation NIST 3 Verify: Biometric system allows no more than 5 consecutive failed authentication attempts Reason: Limit the occurrence of impersonation attacks High Impersonation NIST 4 Verify: After 5 consecutive failed attempts disable authentication for 30 seconds before next attempt and increase exponentially with each successive failed attempt or disable the biometric user authentication and offer another factor Reason: Limit guessing High Bruteforcing NIST 5 Verify: Integrity of the endpoint or sensor can be determined so any sensor or endpoint change can be detected Reason: Prevent an attacker from installing a fraudulent device to bypass biometric check High Impersonation NIST \ud83d\udd17 References: Open Web Application Security Project (OWASP): Application Security Verification Checklist - Authentication Authentication Cheat Sheet Security Question Cheat Sheet National Institute of Standards and Technology (NIST) SP 800-63B: 5 Authenticator and Verifier Requirements","title":"\ud83e\uddec Biometric"},{"location":"Defensive-Strategies/Cryptography/","text":"","title":"Cryptography"},{"location":"Defensive-Strategies/Input-Validation/","text":"","title":"Input Validation"}]}